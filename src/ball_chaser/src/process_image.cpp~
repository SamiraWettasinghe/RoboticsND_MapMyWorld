#include "ros/ros.h"
#include "ball_chaser/DriveToTarget.h"
#include <sensor_msgs/Image.h>

ros::ServiceClient client;

void drive_robot(float lin_x, float ang_z)
{
    ball_chaser::DriveToTarget srv;
    srv.request.linear_x = lin_x;
    srv.request.angular_z = ang_z;

    if (!client.call(srv)){
        ROS_ERROR("Failed to call service command_robot");
    }
}

void process_image_callback(const sensor_msgs::Image img)
{
    // init local temp variables
    int white_pixel = 255;
    int pix_sum = 0;
    int num_white = 0;
    int pix_x = 0;
    int k = 0;
    float cov = 0.0;
    float x = 0.0;
    float z = 0.0;

    // image payload and header
    int step = img.step;
    int h = img.height;
    int w = img.width;

    for (int i = 0; i < step; i++){  // width
        for (int j = 0; j < h; j++){ // height
            if (k < 3){ // check if pixel is past B value
                pix_sum += img.data[i + j*step]; // sum R, G, or B value
                k++;
            }
            else{
		ROS_INFO_STREAM("white detected");
                if(pix_sum == white_pixel*3){ // if at B value, check if pixel is white (255, 255, 255)
                    if ((i % 3) == 0){ // x location of last white pixel detected
                        pix_x = i/3;
                    }
                    else{
                        pix_x = i/3 + 1;
                    }

                    num_white++; // increment confirmed white pixel counter
                }

                pix_sum = img.data[i + j*step];
                k = 1;
            }
        }
    }

    cov = num_white/(h*w); // ratio of white pixels to others in image


    if (cov > 0.05){
        if (pix_x <= w/3.0){
            z = 0.5;
            x = 0.5/cov/10.0;
        }
        else if (w/3 < pix_x <= 2.0*w/3.0){
            z = 0.0;
            x = 0.5/cov/10.0;
        }
        else if (pix_x > 2.0*w/3.0){
            z = -0.5;
            x = 0.5/cov/10.0;
        }
        else{
            z = 0.0;
            x = 0.0;
        }
    }
    else{
        z = 0.0;
        x = 0.0;
    }
    
    drive_robot(x, z);

    /* 
       later:
       determine the projection of the white circle on the x and y axis.
       this will give a very accurate prediction of the centre location
       of the sphere.
       
       linear velocity will be scaled by how far away ball if from centre,
       far away from centre = slow vel.
       angular velociy will be scaled by white pixel ratio,
       small ratio = slow vel.
       
       if x and y projections are not equal in size, that means ball
       is partially off camera.
       if this is the case, rotate camera slowly with zero linear vel
       to get full image of ball in view.
    */
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "process_image");
    ros::NodeHandle n;

    client = n.serviceClient<ball_chaser::DriveToTarget>("/ball_chaser/command_robot");

    ros::Subscriber sub1 = n.subscribe("/camera/rgb/image_raw", 10, process_image_callback);

    ros::spin();

    return 0;
}
